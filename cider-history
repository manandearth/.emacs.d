;; -*- coding: utf-8-unix -*-
;; Automatically written history of CIDER REPL session
;; Edit at your own risk

("(+ 9 9)" "(fw/cljs-repl)" "(fw/start-figwheel!)" "(require '[figwheel-sidecar.repl-api :as fw])" "(fw/start-figwheel!)" "(require '[figwheel-sidecar.repl-api :as fw])" "(+ 9 9)" "(-> (ping 440)
    (connect-> destination)
    (run-with context (current-time context) 1.0)))" "(ping 255)" "(ping)" "ping" "(+ 9 9)" "(fw/cljs-repl)" "(fw/start-figwheel!)" "(require '[figwheel-sidecar.repl-api :as fw])" "(+ 9 9)" "(js/alert \"Boo!\")" "(prn \"Boo!\")" "(println \"Boo!\")" "(fw/cljs-repl)" "(fw/start-figwheel!)" "(require '[figwheel-sidecar.repl-api :as fw])" "@(subscribe [::selected-system])" "(subscribe [::selected-system])" "(subscribe [::spheres])" "(subscribe [::sphere])" "(subscribe [::name])" "(subscribe ::name)" "(subscribe ::sphere)" "(subscribe ::spheres)" "(+ 2 2)" "aaa" "(+ 1 1)" "(fig-status)" "(fw/cljs-repl)" "(fw/start-figwheel!)" "(require '[figwheel-sidecar.repl-api :as fw])" "(fw/re-start-figwheel!)" "(+ 1 1)" "(js/alert \"2\")" "(+ 1 1)" "(js/alert \"2\")" "(fw/cljs-repl)" "(fw/start-figwheel!)" "(require '[figwheel-sidecar.repl-api :as fw])" "(+ 9 9)" "(get-in spheres-map [:volume \"Venus\"])" "(get-in spheres-map [:volume] \"Venus\")" "(get-in spheres-map :volume \"Venus\")" "(get spheres-map \"Venus\")" "spheres-map" "(js/alert \"2\")" "(fw/cljs-repl)" "(fw/start-figwheel!)" "(require '[figwheel-sidecar.repl-api :as fw])" "(+ 9 9)" "(fw/cljs-repl)" "(fw/start-figwheel!)" "(require '[figwheel-sidecar.repl-api :as fw])" "(+ 9 9)" "(fw/cljs-repl)" "(fw/start-figwheel!)" "(require '[figwheel-sidecar.repl-api :as fw])" "(fw/start-figwheel!)" "(+ 9 9)" "(+ 2 2)" "(fw/cljs-repl)" "(fw/start-figwheel!)" "(require '[figwheel-sidecar.repl-api :as fw])" "(+ 2 2)" "(fw/cljs-repl)" "(fw/start-figwheel!)" "(require '[figwheel-sidecar.repl-api :as fw])" "(fw/cljs-repl)" "(fw/start-figwheel!)" "(require '[figwheel-sidecar.repl-api :as fw])" "(+ 9 9)" "(fw/cljs-repl)" "(fw/start-figwheel!)" "(require '[figwheel-sidecar.repl-api :as fw])" "(midday-habit person-2)" "(midday-habit person-1)" "(midday-habit person-2)" "(js/alert \"2\")" "  (for [item (vals (:spheres my-map))]
                      (if (:included item)
                        item))" "my-map" "  (def my-map {:spheres {\"one\" {:id 1 :number 1 :name \"one\"}
                                           \"two\" {:id 2 :number 2 :name \"two\"}
                                           \"three\" {:id 3 :number 3 :name \"three\" :included true}}})" "my-map" "  (for [item (vals (:spheres my-map))]
                      (if (:included item)
                        item))" "  (for [item (:spheres my-map)]
                      (if (:included item)
                        item))" "  (get (:spheres my-map) \"three\")" "(:spheres my-map)" "my-map" "  (def my-map {:spheres {\"one\" {:id 1 :number 1 :name \"one\"}
                                           \"two\" {:id 2 :number 2 :name \"two\"}
                                           \"three\" {:id 3 :number 3 :name \"three\" :included true}}})" "  (def my-map {:spheres {\"one\" {:id 1 :number 1 :name \"one\"}
                                           \"two\" {:id 2 :number 2 :name \"two\"}
                                           \"three\" (:id 3 :number 3 :name \"three\" :included true)}})" "  (update (:spheres default-db) dissoc [\"Sun\" :vis] )" "  (update (:spheres default-db) assoc-in [\"Sun\" :vis] false)" "(update default-db assoc-in :spheres [\"Sun\" :vis] false)" "(assoc-in default-db [:spheres \"Sun\" :vis] false)" "(assoc-in default-db [:spheres \"Sun\" :included] false)" "( map :included (vals (:spheres default-db)))" "( map :vis (vals (:spheres default-db)))" "( map :included (vals (:spheres default-db)))" "  (:included (get (:spheres default-db) \"Uranus\"))" "  (:included (get (:spheres default-db) \"Deimos\"))" "  (:included (get (:spheres default-db) \"Uranus\"))" "  (get (:spheres default-db) \"Uranus\")" "  (get default-db \"Uranus\")" "  (\"Uranus\" default-db)" "default-db" "( map :included (vals (:spheres default-db)))" "( map :vis (vals (:spheres default-db)))" "( map :form (vals (:spheres default-db)))" "( map :form (:spheres default-db))" "(:spheres default-db)" "(map :vis (:spheres default-db))" "default-db" " (filter #(> ( :mass %) 10000000) (subscribe [::subs/spheres-vals]))" " (comp :mass (subscribe [::subs/spheres-vals]))" " (:mass (subscribe [::subs/spheres-vals]))" " (map :mass (subscribe [::subs/spheres-vals]))" " (subscribe [::subs/spheres-vals])" " (\"Earth\" (subscribe [::subs/spheres-vals]))" " (\"earth\" (subscribe [::subs/spheres-vals]))" " (subscribe [::subs/spheres-vals])" "(first (subscribe [::subs/spheres-vals]))" " (subscribe [::subs/spheres-vals])" "(filter :id (subscribe [::subs/spheres-vals]))" "(subscribe [::subs/spheres-vals])" "(fw/cljs-repl)" "(fw/start-figwheel!)" "(+ 9 9)" "(fw/cljs-repl)" "(+ 9 9)" "(fw/start-figwheel!)" "(require '[figwheel-sidecar.repl-api :as fw])" "(balance bea-account)" "(transaction bea-account 101 \"Money from Christmas\")" "(balance bea-account)" "(js/alert \"2\")" "(+ 9 9)" "(fw/cljs-repl)" "(fw/start-figwheel!)" "(require '[figwheel-sidecar.repl-api :as fw])" "(s/explain-data ::string-int :string)" "(s/explain ::string-int :string)" "(s/explain ::string-int *)" "(s/explain ::string-int 3)" "(s/explain ::string-int 0.3)" "(s/explain ::string-int 0,3)" "(s/valid? ::string-int 0.3)" "(s/valid? ::string-int \"22\")" "(s/valid? ::string-int 12)" "(s/def ::string-int (s/or :string string?
                                :int int?))" "(s/valid? ::big-or-small-or-string \"Bob\")" "(s/valid? ::big-or-small-or-string 1002)" "(s/valid? ::big-or-small-or-string 1000)" "(s/valid? ::big-or-small-or-string 100)" "(s/valid? ::big-or-small-or-string 10)" "(s/def ::big-or-small-or-string (s/or :big #( > % 1000)
                                            :small #(> 100 %)
                                            :string string?))" "(s/def ::big-or-small-or-string (s/or :big #( > % 1000)
                                            :small #(> 100 %)
                                            :string strig?))" "(s/valid? ::big-or-small 99)" "(s/valid? ::big-or-small 100)" "(s/valid? ::big-or-small 1000)" "(s/valid? ::big-or-small 1001)" "(valid? ::big-or-small 1001)" "(s/def ::big-or-small (s/or :big #( > % 1000)
                                 :small #(> 100 %)))" "(s/def :big-or-small (s/or :big #(> % 1000)
                                 :small #(> 100 %)))" "(s/def :big-or-small (s/or  :big #(> % 1000)
                                  :small #(> 100 %)))" "(s/def :big-or-small (s/or  #(> % 1000) #(> 100 %)))" "(s/def :big-or-small (s/or  #(> % 1000) #(< 100 %)))" "(s/def :big-or-small (s/or  #(> % 1000) #(< % 100)))" "(s/conform ::big-even 10010)" "(s/conform ::big-even 1001)" "(s/conform ::big-even 1002)" "(s/def ::big-even (s/and #(> % 1000) even? int?))" "(s/def ::big-even (s/and (> % 1000) even? int?))" "(doc ::suit)" "(s/conform ::suit :spade)" "(s/conform ::suit :diamo)" "(s/conform ::suit :diamond)" "(s/def ::suit #{:club :diamond :heart :spade})" "(s/def ::suit #{:club :diamond :heart :spade} :spade)" "(s/valid? #{:club :diamond :heart :spade} :spade)" "(s/valid? #{:club :diamond :heart :spade})" "(s/conform #(< 10 % 20) 19)" "(s/conform #(< 10 % 20) 191)" "(s/conform #(> 10 % 20) 191)" "(s/conform #(> 10 % 20) 19)" "(s/conform #(> 10 % 20) 9)" "(s/conform #(> 10 % 20) 13)" "(s/conform even? 14)" "(s/conform even? 13)" "(s/valid? even? 13)" "(s/valid? even? 14)" "(s/valid even? 14)" "(s/valid even? 13)" "(require '[clojure.spec.alpha :as s])" "(require [clojure.spec.alpha :as s])" "(import java.util.Date)" "(fw/start-figwheel!)" "(require '[figwheel-sidecar.repl-api :as fw])" "(+ 1 1)" "(print \"ASDASD\")" "print (\"ASDASD\")" "earth" "(fw/cljs-repl)" "(fw/start-figwheel!)" "(require '[figwheel-sidecar.repl-api :as fw])" "(fw/cljs-repl)" "(fw/start-figwheel!)" "(require '[figwheel-sidecar.repl-api :as fw])" "(require [figwheel-sidecar.repl-api :as fw])" " (.log js/Math 1)" " (.log js/Math 0)" "(* 40 (.log js/Math 0))" "(filter #(= (:name %) \"Sun\") @(subscribe [::subs/spheres-vals]))" "(filter (= :name \"Sun\") @(subscribe [::subs/spheres-vals]))" "(get @(subscribe [::subs/spheres-vals]) :sun)" "(get @(subscribe [::subs/spheres-vals]) \"sun\")" "(get @(subscribe [::subs/spheres-vals]) \"Sun\")" "@ (subscribe [::subs/spheres-vals])" " (subscribe [::subs/spheres-vals])" "(get (subscribe [::subs/spheres-vals]) \"Sun\")" "(\"Sun\" (subscribe [::subs/spheres-vals]))" "(:sun  (subscribe [::subs/spheres-vals]))" "(subscribe [::subs/spheres-vals])" "(:earth (subscribe ::subs/spheres-vals))" "(subscribe ::subs/spheres-vals)" "@(subscribe ::subs/spheres-vals)" "(subscribe [::subs/x-select])" "(subscribe [::subs/spheres-vals])" "default-db" "(in-ns spheres-rf.db)" "(fw/cljs-repl)" "(fw/start-figwheel!)" "(require '[figwheel-sidecar.repl-api :as fw])" "(+ 1 1)" "(update my-vec 3 {:g 8})" "(update my-vec 1 {:g 8})" "(update my-vec {:g 8})" "(update my-vec  assoc {:g 8})" "(update-in my-vec 2 assoc {:g 8})" "(dissoc my-vec 2 )" "(dissoc my-vec  {:e 5 :f 6} )" "(update my-vec dissoc {:e 5 :f 6} )" "(def my-vec [{:a 1 :b 2} {:c 3 :d 4} {:e 5 :f 6}])" "(.indexof (to-array my-vec) (first (to-array my-vec)))" "(first (to-array my-vec))" "(first (to-arr))" "(for [i (to-array my-vec)] i)" "(.indexOf (to-array my-vec) {})" "(.indexOf (to-array my-vec) :b)" "(.indexOf (to-array my-vec) 3)" "(.indexOf (to-array my-vec) {:a 1 :b 2})" "(.indexOf (to-array my-vec) #{:a 1 :b 2})" "(.indexOf (to-array my-vec) {:a 1 :b 2})" "(.indexOf {:a 1 :b 2} (to-array my-vec))" "(.indexOf {:a 1 :b 2} my-vec)" "(def my-vec [{:a 1 :b 2} {:c 3 :d 4} {:e 5 :f 6}])" "(for [a [:a :b :c] b])" "(for [a [:a :b :c] b (range (count [:a :b :c]))] {a b})" "(for [a [:a :b :c] b (range [:a :b :c])] {a b})" ")] {a b})" "(for [a [:a :b :c] b (range [:a :b :c])] {a b})" "(for [a [:a :b :c] b (count [:a :b :c])] {a b})" "(for [a [:a :b :c] b (count a)] (a b))" "(for [a [:a :b :c]] a)" "(fw/cljs-repl
       )" "(fw/start-figwheel!)" "(require '[figwheel-sidecar.repl-api :as fw])" "(js/Math.log 1000000000000000)" "(js/Math.log 100000000000)" "(js/Math.log 100000000)" "(js/Math.log 100000)" "(js/Math.log 10)" "(.log 10)" "(.log js/Math 10)" "(js.Math/log 10)" "(.Math/log 10)" "(js/log 10)" "(fw/cljs-repl
       )" "(fw/start-figwheel!)" "(require '[figwheel-sidecar.repl-api :as fw])" "(+ 9 9)" "(fw/cljs-repl
       )" "(fw/start-figwheel!)" "(require '[figwheel-sidecar.repl-api :as fw])" "(fw/cljs-repl
       )" "(fw/start-figwheel!)" "(require '[figwheel-sidecar.repl-api :as fw])" "(fw/cljs-repl
       )" "(fw/start-figwheel!)" "(require '[figwheel-sidecar.repl-api :as fw])" "(require 'tubax.core)" "(fw/cljs-repl
       )" "(fw/start-figwheel!)" "(require '[figwheel-sidecar.repl-api :as fw])" "(fw/cljs-repl
       )" "(fw/start-figwheel!)" "(require '[figwheel-sidecar.repl-api :as fw])" "\"2\"" "(fw/cljs-repl
       )" "(fw/start-figwheel!)" "(require '[figwheel-sidecar.repl-api :as fw])" "(:todos my-subs)" "(filter :completed (:todos my-subs))" "(remove :completed (:todos my-subs))" "(remove :completed my-subs)" "(filter :completed my-subs)" "(def my-subs {:todos [{:id random-uuid
                                       :title \"go go!\"
                                      :completed false}
                                     {:id random-uuid
                                      :title \"cutie pie\"
                                      :completed false}]})" "(def my-subs {:todos {:id random-uuid
:title \"go go!\"
:completed false}
{:id random-uuid
:title \"cutie pie\"
:completed false}})" "(def my-subs {:todos {:id random-uuid}})" "(fw/cljs-repl)" "(fw/start-figwheel!)" "(require '[figwheel-sidecar.repl-api :as fw])" "\"2\"" "counter" "(fw/cljs-repl)" "(fw/start-figwheel!)" "(require '[figwheel-sidecar.repl-api :as fw])" "(for [[[a b] c] my-db]
                 {:pair {a b}
                    :color c})" "(for [[[a b] c] my-db]
                 {:paira a
                  :pairb b
                  :color c})" "(for [[[a b] c] my-db]
                 ({:pair {a b} :color c}))" "(map (fn [[[a b] c]]
                      (for [])) my-db)" "(map (fn [[[a b] c]] [a b c]) my-db)" "(map (fn [[[a b] c]] {a c}) my-db)" "(map (fn [[[a b] c]] (* a b)) my-db)" "(map (fn [[a b] c] (* a b)) my-db)" "my-db" "(def my-db {[1 2] 3
                           [4 5] 6
                           [7 8] 9})" "(def my-db {[1 2] 3})" "db" "(let [{a b} el]
              a)" "(let [a el]
             (keys a))" "(let [el a]
             (keys a))" "(let [{[a b] c} el ]
             (+ a b))" "(let [el {[a b] c}]
             (+ a b))" "(let [{[a b ] c} el]
             (+ a b))" "(let [[[a b ] c] el]
             (+ a b))" "(let [el [[a b ] c ]]
             (+ a b))" "(let [el [[a b ] c ]]
             (+ a c))" "(let [el [[a b ] c]]
             (+ a c))" "(let [el [[a b ]c]]
             (+ a c))" "(let [[[a b ]c] el]
             (+ a c))" "(let [[[a b ]c] el])" "el" "(def el {[1 2] 3})" "(js/alert \"2\")" "(alert \"2\")" "(fw/cljs-repl)" "(fw/start-figwheel!)" "(require '[figwheel-sidecar.repl-api :as fw])" "my-vec" "(filter (even?) (map :id my-vec))" "(filter (even? :id) my-vec)" "(contains? #(:id 1) my-vec)" "(contains? (:id 1) my-vec)" "(filter (contains? (:id 1)) my-vec)" "(filter #(:id 1) my-vec)" "my-vec" "(def my-vec [{:id 1 :name \"Jo\"} {:id 2 :name \"Chris\"} {:id 3 :name \"Sophie\"} {:id 4 :name \"Adam\"}])" "@app-state" "(swap! app-state update-in [:columns 0 :cards] disj 0 )" "(swap! app-state update-in [:columns 0 :cards] (.-delete 0 ) )" "(swap! app-state update-in [:columns 0 :cards] disj 0 )" "(swap! app-state update-in [:columns 0 :cards 1] dissoc :title )" "(swap! app-state update-in [:columns 0 :cards 0] dissoc :title )" "(swap! app-state update-in [:columns 0 :cards 0] dissoc :id )" "(swap! app-state update-in [:columns 0] dissoc :id )" "(swap! app-state update-in [:columns 0] disj :id )" "(swap! app-state update :column disj {})" "(swap! app-state update :column disj 0)" "@app-state" "@my-atom" "@app-state" "(swap! my-atom dissoc [:cards 1] :title)" "(swap! my-atom assoc-in [:cards 1 :title] \"choochoo\")" "(swap! my-atom update (:title (nth (:cards) 1)) \"choochoo\")" "(swap! my-atom update (:title (nth (:cards %) 1)) \"choochoo\")" "(swap! my-atom update #(:title (nth (:cards %) 1)) \"choochoo\")" "(swap! my-atom update #(:title (nth (:cards %)1 )) \"choochoo\")" "@my-atom" "(swap! my-atom update #(:title (nth (:cards) % )1) \"choochoo\")" "(swap! my-atom update #(:title (nth (:cards) % 1)) \"choochoo\")" "(swap! my-atom update (:title (nth (:cards) % 1)) \"choochoo\")" "(:title (nth (:cards @my-atom) 1))" "@my-atom" "(swap! my-atom update-in :cards  :title \"choochoo!\" )" "@my-atom" "(swap! my-atom update-in :cards 1 :title \"choochoo!\" )" "(def my-atom (atom {:id 1
                                  :title \"todo\"
                                  :cards [{:id 11 :title \"coco\"}
                                          {:id 12 :title \"banana\"}
                                          {:id 13 :title \"chocolate\"}]}))" "@my-atom" "(swap! my-atom update-in :cards 1 :title \"choochoo!\" )" "(swap! my-atom assoc :cards  update :title \"choochoo!\" )" "@my-atom" "(swap! my-atom update :cards \"choo!\" )" "(filter even? (:id (get @my-atom :cards)))" "(every? #(< 11 (:id %)) (get @my-atom :cards))" "@my-atom" "(every? #(> 11 (:id %)) (get @my-atom :cards))" "(filter (contains? :id) (get @my-atom :cards))" "(filter (= 1 :id) (get @my-atom :cards))" "(concat (subvec (get @my-atom :cards ) 0 1) (subvec (get @my-atom :cards ) 2))" "(subvec (get @my-atom :cards ) 0 1)" "(subvec (get @my-atom :cards ) 1)" "(get @my-atom :cards )" "@my-atom" "(get-in @my-atom :cards 1)" "(get-in @my-atom :cards)" "@my-atom" "(def my-atom (atom {:id 1
                                  :title \"todo\"
                                  :cards [{:id 11 :title \"coco\"}
                                          {:id 12 :title \"banana\"}
                                          {:id 13 :title \"chocolate\"}]}))" "@my-atom" "(swap! @my-atom   :cards 1  )" "(swap! @my-atom  update :cards 1  )" "@my-atom" "(swap! @my-atom  :cards :a 1 )" "(swap! @my-atom update :cards :a 1 )" "(swap! @my-atom merge :cards :a 1 )" "(swap! @my-atom assoc :cards :a 1 )" "(swap! @my-atom assoc :cards {:a 1} )" "(swap! @my-atom update :cards  dissoc 1 )" "(swap! @my-atom update-in :cards  dissoc 1 )" "@my-atom" "(swap! @my-atom update-in 2 dissoc 1 )" "(swap! @my-atom update-in 2 disj 1 )" "(swap! @my-atom update-in 2 concat {:result 1} )" "(swap! @my-atom update-in 2 conj {:result 1} )" "(swap! @my-atom update-in 2 merge {:result 1} )" "(swap! @my-atom disj :cards)" "(swap! @my-atom disj :cards 1 )" "@my-atom" "(swap! @my-atom assoc :cards {1 2}  )" "(swap! @my-atom assoc :cards 1 2  )" "(swap! @my-atom dissoc :cards  )" "@my-atom" "(swap! @my-atom dissoc :cards 2 )" "@my-atom" "(swap! @my-atom dissoc :cards)" "@my-atom" "(def my-atom (atom {:id 1
                                  :title \"todo\"
                                  :cards [{:id 11 :title \"coco\"}
                                          {:id 12 :title \"banana\"}
                                          {:id 13 :title \"chocolate\"}]}))" "@my-atom" "my-reset" "@my-atom" "(swap! @my-atom get-in [:val :cards])" "(swap! @my-atom get-in :val :cards)" "@my-atom" "my-reset" "(swap! @my-atom dissoc :val 1)" "@my-atom" "(swap! my-atom update :cards assoc :1 2)" "(swap! my-atom update :cards assoc 1)" "(swap! my-atom update :cards assoc [1])" "(swap! my-atom update :cards assoc 1 [1])" "(swap! my-atom dissoc :cards)" "my-reset" "(def my-reset (reset! my-atom (atom {:id 1
                                                   :title \"todo\"
                                                   :cards [{:id 11 :title \"coco\"}
                                                           {:id 12 :title \"banana\"}
                                                           {:id 13 :title \"chocolate\"}]})))" "@my-atom" "(def my-atom (atom {:id 1
                                  :title \"todo\"
                                  :cards [{:id 11 :title \"coco\"}
                                          {:id 12 :title \"banana\"}
                                          {:id 13 :title \"chocolate\"}]}))" "@my-atom" "(swap! my-atom dissoc :cards)" "(swap! my-atom dissoc-in :cards 1  )" "(swap! my-atom dissoc :cards  )" "(swap! my-atom update :cards disj 1)" "(swap! my-atom update :cards dissoc 1 1)" "(swap! my-atom update :cards dissoc 1)" "(swap! my-atom update :cards assoc 1 [1])" "(swap! my-atom update :cards assoc [1])" "(swap! my-atom update :cards [1])" "@my-atom" "(def my-atom (atom {:id 1
                                  :title \"todo\"
                                  :cards [{:id 11 :title \"coco\"}
                                          {:id 12 :title \"banana\"}
                                          {:id 13 :title \"chocolate\"}]}))" "@my-atom" "(def my-atom {:id 1
                            :title \"todo\"
                            :cards [{:id 11 :title \"coco\"}
                                    {:id 12 :title \"banana\"}
                                    {:id 13 :title \"chocolate\"}]})" "@app-state" "@my-atom" "my-atom" "@app-state" "app-state" "(nth (:cards (nth (:columns @app-state) 1))1)" "(:cards (nth (:columns @app-state) 1))" "(nth (:columns @app-state) 1)" "(nth (nth (:columns @app-state) 1) 1)" "(nth (:columns @app-state) 1)" "(:cards @app-state)" "@app-state" "(swap! my-atom update :cards (concat (subvec 0 1) (subvec inc 1)))" "(swap! my-atom update :cards subvec 2 )" "(!swap my-atom update :cards subvec 2 )" "@my-atom" "my-atom" "(def my-atom (atom {:cards [{:id \"a\", :type \"thing\"} {:id \"b\", :type \"thing\"} {:id \"c\", :type \"thing\"}]}))" "my-atom" "(def my-atom my-map)" "my-map" "(subvec (:cards my-map) 1 )" "(update (:cards my-map) 1 )" "(dissoc (:cards my-map) 1 )" "(disj (:cards my-map) 1 )" "(disj  my-map :cards )" "(dissoc my-map (1 :cards) )")